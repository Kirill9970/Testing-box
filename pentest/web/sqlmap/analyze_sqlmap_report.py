import sys
from pathlib import Path
from datetime import datetime
import re

HTML_TEMPLATE = '''
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Отчет sqlmap</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 40px; background: #f8f9fa; }}
        h1 {{ color: #2c3e50; }}
        h2 {{ color: #1a5276; margin-top: 40px; }}
        table {{ border-collapse: collapse; width: 100%; margin: 20px 0; background: #fff; }}
        th, td {{ border: 1px solid #ccc; padding: 10px 16px; text-align: left; vertical-align: top; }}
        th {{ background: #e9ecef; }}
        .desc {{ margin-top: 30px; color: #555; }}
        .block {{ background: #f4f4f4; border-radius: 4px; padding: 8px; font-family: monospace; white-space: pre-wrap; max-height: 300px; overflow: auto; }}
        .warn {{ color: #e67e22; }}
        .err {{ color: #c0392b; font-weight: bold; }}
        .info {{ color: #2980b9; }}
    </style>
</head>
<body>
    <h1>Отчет по результатам сканирования sqlmap</h1>
    <div class="desc">
        <h2>Сводка</h2>
        <ul>
            <li>В таблице ниже — все ключевые сообщения sqlmap (WARNING, ERROR, INFO).</li>
            <li>Если найдены уязвимости, они будут выделены.</li>
            <li>Весь лог сканирования доступен в конце отчёта.</li>
        </ul>
    </div>
    {findings_table}
    <div class="desc">
        <h2>Полный лог сканирования</h2>
        <div class="block">{full_log}</div>
    </div>
</body>
</html>
'''

def parse_sqlmap_txt(path):
    findings = []
    full_log_lines = []
    with open(path, encoding='utf-8') as f:
        for line in f:
            full_log_lines.append(line.rstrip())
            m = re.match(r'\[(\d{2}:\d{2}:\d{2})\] \[(WARNING|ERROR|INFO)\] (.*)', line)
            if m:
                time, level, msg = m.groups()
                findings.append({'time': time, 'level': level, 'msg': msg})
    return findings, '\n'.join(full_log_lines)

def render_findings_table(findings):
    if not findings:
        return '<h2>Нет найденных проблем или файл отчета пустой.</h2>'
    rows = ['<tr><th>#</th><th>Время</th><th>Тип</th><th>Сообщение</th></tr>']
    for i, f in enumerate(findings):
        level_class = {'WARNING': 'warn', 'ERROR': 'err', 'INFO': 'info'}.get(f['level'], '')
        rows.append(f'<tr>'
                    f'<td>{i+1}</td>'
                    f'<td>{f["time"]}</td>'
                    f'<td class="{level_class}">{f["level"]}</td>'
                    f'<td>{f["msg"]}</td>'
                    f'</tr>')
    return '<table>' + '\n'.join(rows) + '</table>'

def main():
    if len(sys.argv) < 2:
        print('Usage: python3 analyze_sqlmap_report.py <sqlmap_report.txt>')
        sys.exit(1)
    input_path = Path(sys.argv[1])
    dt_str = datetime.now().strftime('%Y%m%d_%H%M%S')
    output_path = Path(__file__).resolve().parents[3] / 'reports' / 'pentest' / 'sqlmap' / f'sqlmap_report_{dt_str}.html'
    findings, full_log = parse_sqlmap_txt(input_path)
    findings_table = render_findings_table(findings)
    html = HTML_TEMPLATE.format(findings_table=findings_table, full_log=full_log)
    output_path.parent.mkdir(parents=True, exist_ok=True)
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(html)
    print(f'HTML-отчет сгенерирован: {output_path}')

if __name__ == '__main__':
    main() 